# FuzzTypes

FuzzTypes is a set of "autocorrecting" annotation types that expands
upon [Pydantic](https://github.com/pydantic/pydantic)'s included [data
conversions.](https://docs.pydantic.dev/latest/concepts/conversion_table/)
Designed for simplicity, it provides powerful normalization capabilities
(e.g. named entity linking) to ensure structured data is composed of
"smart things" not "dumb strings".

### Basic Use Case

Pydantic supports basic conversion of data between types. For instance:

```python
from pydantic import BaseModel

class Normal(BaseModel):
    boolean: bool
    float: float
    integer: int
    
obj = Normal(
    boolean='yes',
    float='2',
    integer='3',
)
assert obj.boolean is True
assert obj.float == 2.0
assert obj.integer == 3
```

FuzzTypes expands on the standard data conversions handled by Pydantic and
provides a variety of autocorrecting annotation types. 

```python
from pydantic import BaseModel
from fuzztypes import (
    ASCII,
    Datetime,
    Email,
    Fuzzmoji,
    InMemory,
    Integer,
    Person,
    Regex,
    ZipCode,
    flags,
)

inventors = ["Ada Lovelace", "Alan Turing", "Claude Shannon"]
Inventor = InMemory(inventors, search_flag=flags.FuzzSearch)
Handle =  Regex(r'@\w{1,15}', examples=["@genomoncology"])


class Fuzzy(BaseModel):
    ascii: ASCII
    email: Email
    emoji: Fuzzmoji
    handle: Handle
    integer: Integer
    inventor: Inventor 
    person: Person
    time: Datetime
    zipcode: ZipCode
    
obj = Fuzzy(
    ascii="Œ¨ŒΩŒ∏œÅœâœÄŒøœÇ",
    email="John Doe <jdoe@example.com>",
    emoji='thought bubble',
    handle='Ian Maurer (@imaurer)',
    integer='fifty-five',
    inventor='ada luvlace',
    person='mr. arthur herbert fonzarelli (fonzie)',
    time='5am on Jan 1, 2025',
    zipcode="(Zipcode: 12345-6789)",
)
# greek for man: https://en.wiktionary.org/wiki/Œ¨ŒΩŒ∏œÅœâœÄŒøœÇ
assert obj.ascii == "anthropos"
# extract email via regular expression
assert obj.email == "jdoe@example.com"
# fuzzy match "thought bubble" to "thought balloon" emoji
assert obj.emoji == "üí≠"
# simple, inline regex example (see above Handle type)
assert obj.handle == "@imaurer"
# convert integer word phrase to integer value
assert obj.integer == 55
# case-insensitive fuzzy match on lowercase, misspelled name
assert obj.inventor == "Ada Lovelace"
# human name parser (title, first, middle, last, suffix, nickname)
assert str(obj.person) == 'Mr. Arthur Herbert Fonzarelli (fonzie)'
assert obj.person.short_name == "Arthur Fonzarelli"
assert obj.person.nickname == "fonzie"
assert obj.person.last == "Fonzarelli"
# convert time phrase to datetime object
assert obj.time.isoformat() == "2025-01-01T05:00:00"
# extract zip5 or zip9 formats using regular expressions
assert obj.zipcode == "12345-6789"
```

Types can also be used outside of Pydantic models to validate and normalize data:

```python
from fuzztypes import Date, Fuzzmoji

# access value via "call" (parenthesis)
assert Date("1 JAN 2023").isoformat() == "2023-01-01"
assert Fuzzmoji("tada") == 'üéâ'

# access entity via "key lookup" (square brackets)
assert Fuzzmoji["movie cam"].value == "üé•"
assert Fuzzmoji["movie cam"].aliases == [':movie_camera:', 'movie camera']
assert Fuzzmoji["movie cam"].model_dump() == {
    'value': 'üé•',
    'label': None,
    'meta': None,
    'priority': None,
    'aliases': [':movie_camera:', 'movie camera']
}
```


### Installation

Available on [PyPI](https://pypi.org/project/FuzzTypes/):

```bash
pip install fuzztypes
```


### Structured Data Generation Use Case

Several libraries (e.g. [Instructor](https://github.com/jxnl/instructor),
[Outlines](https://github.com/outlines-dev/outlines),
[Marvin](https://github.com/prefecthq/marvin)) use Pydantic to define models for structured data generation
using Large Language Models (LLMs) via function calling or a grammar/regex
based sampling approach based on the [JSON schema generated by Pydantic](https://docs.pydantic.dev/latest/concepts/json_schema/).

This approach allows for the enumeration of allowed values using
Python's `Literal`, `Enum` or JSON Schema's `examples` field directly
in your Pydantic class declaration which is used by the LLM to
generate valid values. This approach works exceptionally well for
low-cardinality (not many unique allowed values) such as the world's
continents (7 in total).

This approach, however, doesn't scale well for high-cardinality (many unique
allowed values) such as the number of known human genomic variants (~325M).
Where exactly the cutoff is between "low" and "high" cardinality is an exercise
left to the reader and their use case. 

That's where FuzzTypes come in. The allowed values are managed by the FuzzTypes
annotations and the values are resolved during the Pydantic validation process.
This can include fuzzy and semantic searching that throws an exception if the
provided value doesn't meet a minimum similarity threshold defined by the 
developer.

Errors discovered via Pydantic can be caught and resubmitted to the LLM for
correction. The error will contain examples, expected patterns, and closest
matches to help steer the LLM to provide a better informed guess.


## Base Types

Foundational types used to define "Usable Types".

| type     | description                                                                  |
|----------|------------------------------------------------------------------------------|
| DateType |                                                                              |
| Function | Provide any function that accepts one value and returns one value.           |
| InMemory | Match to in memory entities via exact, alias, fuzz, or semantic search.      |
| OnDisk   | Match to entities via exact, alias, fuzzy or semantic search using LanceDB.  |
| Regex    | Provide a regular expression pattern for extracting values.                  |
| TimeType | Base time for fuzzy parsing `datetime` objects (e.g. tomorrow @ 5a)          |

## Usable Types

Types that can be used directly in your Pydantic classes.

| Type         | Description                                                                            |
|--------------|----------------------------------------------------------------------------------------|
| ASCII        | Convert Unicode string to ASCII equivalent using `anyascii` or `unidecode`.            |
| Date         | Convert date strings to `Date` object using `dateparser`.                              |
| Email        | Regex for extracting a single valid email from a string.                               |
| Emoji        | Matches emojis based on Unicode Consortium aliases. Utilizes the `emoji` for matching. |
| Fuzzmoji     | Matches emojis based on fuzzy string matching to aliases.                              |
| Integer      | Convert number or ordinal text to an `int` using `number-parser`.                      |
| Person       | Parse human name into subfields (e.g. first, last, suffix) using `python-nameparser`.  |
| SSN          | Regex for extracting a single social security number from a string.                    |
| Time         | Convert date time strings to `DateTime` object using `dateparser`.                     |
| Vibemoji     | Matches emojis based on semantic similarity string matching to aliases.                |
| Zipcode      | Regex for extracting a 5 or 9 digit zipcode from a string.                             |


### Roadmap Types

Not currently implemented...

| Type         | Description                                                                                                 |
|--------------|-------------------------------------------------------------------------------------------------------------|
| Airport      | Represents airport names (e.g., O'Hare International Airport) for detailed aviation-related data.           |
| AirportCode  | Manages airport codes (e.g., ORD) for quick and standardized airport identification.                        |
| Country      | Represents country names, such as Germany or United States, for standardized country identification.        |
| CountryCode  | Handles ISO country codes (e.g., DE, UK, US) for concise representation of countries.                       |
| Currency     | Handles currency codes (e.g., USD) for financial transactions and currency representation.                  |
| Language     | Manages full language names (e.g., English, German) for clear language specification.                       |
| LanguageCode | Deals with ISO language codes (e.g., en, de) for brief language identification.                             |
| Quantity     | Converts strings to Quantity objects, combining value and unit of measurement, via `pint`.                  |
| URL          | Normalized URL with trackers removed using `url-normalize`.                                                 |
| USState      | Represents U.S. state names (e.g., Ohio) for detailed geographical categorization within the United States. |
| USStateCode  | Manages U.S. state codes (e.g., OH) for abbreviated state representation.                                   |

## Common Arguments

| argument        | type    | description                                                                                                               |
|-----------------|---------|---------------------------------------------------------------------------------------------------------------------------|
| case_sensitive  | bool    | If False, matches regardless of case. If True, matches only if case is exact. Default False.                              |
| examples        | list    | Example values used in schema generation.                                                                                 |
| notfound_mode   | Literal | raise: Raises an error if key not found. none: Returns None if key not found. allow: Returns key if not found.            |
| tiebreaker_mode | Literal | raise: Raises error if tied (value, priority). lesser: Returns lower value answer. greater: Returns greater value answer. |
| validator_mode  | str     | before: Resolves value before validation. *Currently the only tested option.*                                             |


## Lazy Dependencies

FuzzTypes leverages several powerful libraries to extend its functionality.

These dependencies are not installed by default with FuzzTypes to keep the
installation lightweight. Instead, they are optional and can be installed
as needed depending on which types you use.

Below is a list of these dependencies, including their licenses, purpose, and what
specific Types require them.

| Fuzz Type  | Library                                                                  | License    | Purpose                                                       |
|------------|--------------------------------------------------------------------------|------------|---------------------------------------------------------------|
| (Multiple) | [sentence-transformers](https://github.com/UKPLab/sentence-transformers) | Apache-2.0 | Encoding sentences into high-dimensional vectors              |
| ASCII      | [anyascii](https://github.com/anyascii/anyascii)                         | ISC        | Converting Unicode text into ASCII equivalents                |
| ASCII      | [unidecode](https://github.com/avian2/unidecode)                         | GPL        | Converting Unicode text into ASCII equivalents                |
| Date       | [dateparser](https://github.com/scrapinghub/dateparser)                  | BSD-3      | Parsing dates from strings                                    |
| Emoji      | [emoji](https://github.com/carpedm20/emoji/)                             | BSD        | Handling and manipulating emoji characters                    |
| Fuzz       | [rapidfuzz](https://github.com/rapidfuzz/RapidFuzz)                      | MIT        | Performing fuzzy string matching                              |
| InMemory   | [numpy](https://numpy.org/)                                              | BSD        | Numerical computing in Python                                 |
| InMemory   | [scikit-learn](https://scikit-learn.org/)                                | BSD        | Machine learning in Python                                    |
| Integer    | [number-parser](https://github.com/scrapinghub/number-parser)            | BSD-3      | Parsing numbers from strings                                  |
| OnDisk     | [lancedb](https://github.com/lancedb/lancedb)                            | Apache-2.0 | High-performance, on-disk vector database                     |
| OnDisk     | [pyarrow](https://github.com/apache/arrow)                               | Apache-2.0 | In-memory columnar data format and processing library         |
| Person     | [nameparser](https://github.com/derek73/python-nameparser)               | LGPL       | Parsing person names                                          |
